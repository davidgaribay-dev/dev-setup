---
- name: Harden and configure Claude development VMs
  hosts: all
  become: true
  gather_facts: true

  pre_tasks:
    - name: Wait for cloud-init to complete
      ansible.builtin.command: cloud-init status --wait
      changed_when: false
      # cloud-init returns 0 for running/not-started, 2 for done/recoverable error
      failed_when: cloud_init_result.rc not in [0, 2]
      register: cloud_init_result
      timeout: 300

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

    - name: Upgrade all packages
      ansible.builtin.apt:
        upgrade: dist
        autoremove: true

    - name: Install Python packages for Ansible modules
      ansible.builtin.apt:
        name:
          - python3-apt
          - python3-pip
        state: present

    - name: Install rsyslog (creates syslog group for hardening)
      ansible.builtin.apt:
        name: rsyslog
        state: present

    - name: Ensure /run/sshd exists (required for ssh_hardening on Ubuntu 24.04)
      ansible.builtin.file:
        path: /run/sshd
        state: directory
        mode: '0755'
        owner: root
        group: root

    # Ensure OpenSSH is updated before hardening (fixes socket-activation issues)
    # Minimum recommended version: 1:9.6p1-3ubuntu13.8
    # See: https://github.com/dev-sec/ansible-collection-hardening/issues/854
    - name: Update OpenSSH to latest version
      ansible.builtin.apt:
        name:
          - openssh-server
          - openssh-client
        state: latest

    # Ubuntu 24.04 uses socket activation by default which conflicts with ssh_hardening
    # See: https://github.com/dev-sec/ansible-collection-hardening/issues/854
    # See: https://discourse.ubuntu.com/t/sshd-now-uses-socket-based-activation-ubuntu-22-10-and-later/30189
    #
    # Best practice approach from DevSec hardening:
    # 1. Remove all socket-related config files
    # 2. Stop, disable, and MASK ssh.socket (mask prevents any re-activation)
    # 3. Reload systemd
    # 4. Enable and start ssh.service

    - name: Remove socket activation configuration files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /etc/systemd/system/ssh.service.d/00-socket.conf
        - /etc/systemd/system/ssh.socket.d/addresses.conf
        - /etc/systemd/system/ssh.service.requires/ssh.socket
        - /etc/systemd/system/sockets.target.wants/ssh.socket

    - name: Stop, disable and mask ssh.socket
      ansible.builtin.systemd:
        name: ssh.socket
        state: stopped
        enabled: false
        masked: true
      register: ssh_socket_result
      failed_when: false

    - name: Log ssh.socket status if unexpected
      ansible.builtin.debug:
        msg: "Note: ssh.socket operation returned: {{ ssh_socket_result.msg | default('OK') }}"
      when: ssh_socket_result is failed

    - name: Reload systemd daemon after socket config removal
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Enable and start traditional SSH service
      ansible.builtin.systemd:
        name: ssh.service
        enabled: true
        state: started

  roles:
    # OS-level hardening (file permissions, kernel params, etc.)
    - role: devsec.hardening.os_hardening
      tags: [hardening]

    # Docker installation
    - role: geerlingguy.docker

  post_tasks:
    # Go installation (direct from go.dev/dl/, bypassing geerlingguy.go role's outdated checksums)
    - name: Check if Go is installed
      ansible.builtin.stat:
        path: /usr/local/go/bin/go
      register: go_binary
      tags: [go]

    - name: Download and install Go {{ go_version }}
      when: not go_binary.stat.exists
      tags: [go]
      block:
        - name: Download Go tarball from go.dev/dl/
          ansible.builtin.get_url:
            url: "https://go.dev/dl/go{{ go_version }}.linux-amd64.tar.gz"
            dest: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
            mode: '0644'

        - name: Extract Go to /usr/local
          ansible.builtin.unarchive:
            src: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
            dest: /usr/local
            remote_src: true

        - name: Remove Go tarball
          ansible.builtin.file:
            path: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
            state: absent

    - name: Add Go to system PATH
      ansible.builtin.copy:
        content: 'export PATH=$PATH:/usr/local/go/bin'
        dest: /etc/profile.d/go.sh
        mode: '0644'
      tags: [go]
    - name: Flush handlers after roles
      ansible.builtin.meta: flush_handlers

    - name: Wait for SSH connection to stabilize after Docker changes
      ansible.builtin.wait_for_connection:
        delay: 5
        timeout: 60


# System configuration (UFW, fail2ban, etc.)
- name: Complete system configuration
  hosts: all
  become: true
  gather_facts: false

  tasks:
    - name: Install development packages
      ansible.builtin.apt:
        name: "{{ dev_packages }}"
        state: present

    # Install Core Services Caddy root CA certificate for HTTPS trust
    # Dynamically fetch from core-services VM to ensure it's always current
    - name: Fetch Caddy root CA certificate from core-services
      ansible.builtin.shell: |
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          {{ core_services_ssh_user }}@{{ core_services_ip }} \
          'sudo cat /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.crt'
      register: caddy_root_ca
      delegate_to: localhost
      become: false
      changed_when: false

    - name: Install Caddy root CA certificate
      ansible.builtin.copy:
        content: "{{ caddy_root_ca.stdout }}"
        dest: /usr/local/share/ca-certificates/caddy-root-ca.crt
        mode: '0644'
      register: caddy_cert_installed

    - name: Update CA certificates trust store
      ansible.builtin.command: update-ca-certificates
      register: update_ca_result
      changed_when: "'1 added' in update_ca_result.stdout or caddy_cert_installed.changed"

    - name: Install UFW
      ansible.builtin.apt:
        name: ufw
        state: present

    - name: Allow SSH through UFW
      community.general.ufw:
        rule: allow
        name: OpenSSH

    - name: Enable UFW with default deny
      community.general.ufw:
        state: enabled
        policy: deny
        direction: incoming

    - name: Allow outgoing traffic
      community.general.ufw:
        state: enabled
        policy: allow
        direction: outgoing

    - name: Install unattended-upgrades
      ansible.builtin.apt:
        name: unattended-upgrades
        state: present

    - name: Enable automatic security updates
      ansible.builtin.copy:
        dest: /etc/apt/apt.conf.d/20auto-upgrades
        content: |
          APT::Periodic::Update-Package-Lists "1";
          APT::Periodic::Unattended-Upgrade "1";
          APT::Periodic::AutocleanInterval "7";
        mode: '0644'

    - name: Install fail2ban
      ansible.builtin.apt:
        name: fail2ban
        state: present

    - name: Configure fail2ban for SSH
      ansible.builtin.copy:
        dest: /etc/fail2ban/jail.local
        content: |
          [sshd]
          enabled = true
          port = ssh
          filter = sshd
          logpath = /var/log/auth.log
          maxretry = 5
          bantime = 3600
          findtime = 600
        mode: '0644'
      notify: Restart fail2ban

    - name: Enable and start fail2ban
      ansible.builtin.systemd:
        name: fail2ban
        enabled: true
        state: started

    - name: Ensure qemu-guest-agent is installed and running
      ansible.builtin.apt:
        name: qemu-guest-agent
        state: present

    - name: Enable and start qemu-guest-agent
      ansible.builtin.systemd:
        name: qemu-guest-agent
        enabled: true
        state: started

    - name: Create keyrings directory
      ansible.builtin.file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Get architecture
      ansible.builtin.command: dpkg --print-architecture
      register: dpkg_arch
      changed_when: false

    - name: Download GitHub CLI GPG key
      ansible.builtin.get_url:
        url: https://cli.github.com/packages/githubcli-archive-keyring.gpg
        dest: /etc/apt/keyrings/githubcli-archive-keyring.gpg
        mode: '0644'

    - name: Verify GitHub CLI GPG key fingerprint
      ansible.builtin.shell: |
        gpg --show-keys --with-fingerprint /etc/apt/keyrings/githubcli-archive-keyring.gpg 2>/dev/null | tr -d ' ' | grep -qi "2C6106201985B60E6C7AC87323F3D4EA75716059"
      register: gh_gpg_verify
      failed_when: gh_gpg_verify.rc != 0
      changed_when: false

    - name: Add GitHub CLI repository
      ansible.builtin.apt_repository:
        repo: "deb [arch={{ dpkg_arch.stdout }} signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main"
        state: present
        filename: github-cli

    - name: Install GitHub CLI
      ansible.builtin.apt:
        name: gh
        state: present
        update_cache: true

  handlers:
    - name: Restart fail2ban
      ansible.builtin.systemd:
        name: fail2ban
        state: restarted


- name: Setup development environment for user
  hosts: all
  become: true
  become_user: "{{ dev_user }}"
  gather_facts: false

  tasks:
    - name: Ensure .local/bin directory exists
      ansible.builtin.file:
        path: "{{ dev_user_home }}/.local/bin"
        state: directory
        mode: '0755'

    - name: Create src directory for code
      ansible.builtin.file:
        path: "{{ dev_user_home }}/src"
        state: directory
        mode: '0755'

    - name: Add .local/bin to PATH in bashrc
      ansible.builtin.lineinfile:
        path: "{{ dev_user_home }}/.bashrc"
        line: 'export PATH="$HOME/.local/bin:$PATH"'
        state: present
        create: true
        mode: '0644'

    - name: Configure git user email
      community.general.git_config:
        name: user.email
        value: "{{ git_user_email }}"
        scope: global

    - name: Configure git user name
      community.general.git_config:
        name: user.name
        value: "{{ git_user_name }}"
        scope: global

    - name: Install NVM
      ansible.builtin.shell: curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/{{ nvm_version }}/install.sh | bash
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/.nvm/nvm.sh"

    - name: Install Node.js LTS via NVM
      ansible.builtin.shell: |
        source {{ dev_user_home }}/.nvm/nvm.sh
        nvm install --lts
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/.nvm/versions/node"

    - name: Install pnpm globally
      ansible.builtin.shell: |
        source {{ dev_user_home }}/.nvm/nvm.sh
        npm install -g pnpm
      args:
        executable: /bin/bash
      register: pnpm_install
      changed_when: "'added' in pnpm_install.stdout"

    - name: Install TypeScript language server (for typescript-lsp plugin)
      ansible.builtin.shell: |
        source {{ dev_user_home }}/.nvm/nvm.sh
        npm install -g typescript typescript-language-server
      args:
        executable: /bin/bash
      register: ts_lsp_install
      changed_when: "'added' in ts_lsp_install.stdout"

    - name: Install UV
      ansible.builtin.shell: curl -LsSf https://astral.sh/uv/install.sh | sh
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/.local/bin/uv"

    - name: Install Pyright language server (for pyright-lsp plugin)
      ansible.builtin.shell: |
        source {{ dev_user_home }}/.nvm/nvm.sh
        npm install -g pyright
      args:
        executable: /bin/bash
      register: pyright_install
      changed_when: "'added' in pyright_install.stdout"

    - name: Install gopls (Go language server for gopls-lsp plugin)
      ansible.builtin.shell: |
        export GOPATH="{{ dev_user_home }}/go"
        export PATH="/usr/local/go/bin:$PATH:$GOPATH/bin"
        go install golang.org/x/tools/gopls@latest
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/go/bin/gopls"

    - name: Add Go paths to bashrc
      ansible.builtin.blockinfile:
        path: "{{ dev_user_home }}/.bashrc"
        marker: "# {mark} ANSIBLE MANAGED - Go paths"
        block: |
          export PATH="/usr/local/go/bin:$PATH"
          export GOPATH="$HOME/go"
          export PATH="$PATH:$GOPATH/bin"

    - name: Install Claude CLI
      ansible.builtin.shell: curl -fsSL https://claude.ai/install.sh | bash
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/.local/bin/claude"

    - name: Download tea CLI
      ansible.builtin.get_url:
        url: https://dl.gitea.com/tea/{{ tea_version }}/tea-{{ tea_version }}-linux-amd64
        dest: /tmp/tea
        mode: '0755'
      become: false
      when: install_gitea_tea | default(false) | bool

    - name: Download tea CLI checksums
      ansible.builtin.get_url:
        url: https://dl.gitea.com/tea/{{ tea_version }}/checksums.txt
        dest: /tmp/tea-checksums.txt
        mode: '0644'
      become: false
      when: install_gitea_tea | default(false) | bool

    - name: Verify tea CLI checksum
      ansible.builtin.shell: |
        cd /tmp && grep "tea-{{ tea_version }}-linux-amd64$" tea-checksums.txt | sha256sum -c -
      register: tea_checksum_verify
      failed_when: tea_checksum_verify.rc != 0
      changed_when: false
      become: false
      when: install_gitea_tea | default(false) | bool

    - name: Install tea CLI
      ansible.builtin.copy:
        src: /tmp/tea
        dest: /usr/local/bin/tea
        mode: '0755'
        remote_src: true
      become: true
      become_user: root
      when: install_gitea_tea | default(false) | bool

    - name: Add UV env sourcing to bashrc
      ansible.builtin.lineinfile:
        path: "{{ dev_user_home }}/.bashrc"
        line: '[ -f "$HOME/.local/bin/env" ] && source "$HOME/.local/bin/env"'
        state: present

    - name: Authenticate gh CLI with token (persists to ~/.config/gh/hosts.yml)
      ansible.builtin.shell: |
        printf '%s' "{{ gh_token }}" | gh auth login --with-token
      args:
        executable: /bin/bash
        creates: "{{ dev_user_home }}/.config/gh/hosts.yml"
      no_log: true
      when: gh_token is defined and gh_token | length > 0

    - name: Setup gh as git credential helper
      ansible.builtin.command: gh auth setup-git
      when: gh_token is defined and gh_token | length > 0
      changed_when: false

    - name: Verify gh authentication
      ansible.builtin.command: gh auth status
      register: gh_auth_status
      changed_when: false
      failed_when: false
      when: gh_token is defined and gh_token | length > 0

    - name: Display gh auth status
      ansible.builtin.debug:
        var: gh_auth_status.stdout_lines
      when: gh_token is defined and gh_token | length > 0 and gh_auth_status is defined

    - name: Create Claude Code config directory
      ansible.builtin.file:
        path: "{{ dev_user_home }}/.claude"
        state: directory
        mode: '0755'

    # Note: Hooks are now managed via plugins (single-command-enforcer@dg-marketplace)
    # configured in settings.json enabledPlugins

    - name: Configure Claude Code settings
      ansible.builtin.template:
        src: files/claude-settings.json.j2
        dest: "{{ dev_user_home }}/.claude/settings.json"
        mode: '0644'

    - name: Skip Claude Code onboarding wizard
      ansible.builtin.copy:
        src: files/claude.json
        dest: "{{ dev_user_home }}/.claude.json"
        mode: '0644'

    - name: Add Context7 MCP server
      ansible.builtin.shell: |
        export PATH="{{ dev_user_home }}/.local/bin:$PATH"
        source {{ dev_user_home }}/.nvm/nvm.sh
        claude mcp add context7 --scope user -- npx -y @upstash/context7-mcp
      args:
        executable: /bin/bash
      register: mcp_add_result
      changed_when: mcp_add_result.rc == 0
      failed_when: false

    - name: Add Playwright MCP server
      ansible.builtin.shell: |
        export PATH="{{ dev_user_home }}/.local/bin:$PATH"
        source {{ dev_user_home }}/.nvm/nvm.sh
        claude mcp add playwright --scope user -- npx -y @playwright/mcp@latest
      args:
        executable: /bin/bash
      register: playwright_mcp_result
      changed_when: playwright_mcp_result.rc == 0

    - name: Display Playwright MCP result
      ansible.builtin.debug:
        msg: "Playwright MCP stdout: {{ playwright_mcp_result.stdout | default('') }} stderr: {{ playwright_mcp_result.stderr | default('') }}"
      when: playwright_mcp_result.rc != 0

    - name: Add Neo4j Cypher MCP server
      ansible.builtin.shell: |
        export PATH="{{ dev_user_home }}/.local/bin:$PATH"
        source {{ dev_user_home }}/.nvm/nvm.sh
        claude mcp add neo4j --scope user -- uvx mcp-neo4j-cypher@0.5.2 --transport stdio
      args:
        executable: /bin/bash
      environment:
        NEO4J_URI: "{{ neo4j_uri }}"
        NEO4J_USERNAME: "{{ neo4j_username }}"
        NEO4J_PASSWORD: "{{ neo4j_password }}"
      register: neo4j_mcp_result
      changed_when: neo4j_mcp_result.rc == 0
      failed_when: false

    - name: Display Neo4j MCP result
      ansible.builtin.debug:
        msg: "Neo4j MCP stdout: {{ neo4j_mcp_result.stdout | default('') }} stderr: {{ neo4j_mcp_result.stderr | default('') }}"
      when: neo4j_mcp_result.rc != 0

    - name: Display Neo4j connection info
      ansible.builtin.debug:
        msg: "Neo4j MCP configured to connect to: {{ neo4j_uri }}"

    - name: Add Plane MCP server (official stdio transport)
      ansible.builtin.shell: |
        export PATH="{{ dev_user_home }}/.local/bin:$PATH"
        source {{ dev_user_home }}/.nvm/nvm.sh
        claude mcp add plane --scope user \
          -e PLANE_API_KEY="{{ plane_api_key }}" \
          -e PLANE_WORKSPACE_SLUG="{{ plane_workspace_slug }}" \
          -e PLANE_BASE_URL="{{ plane_api_url }}" \
          -e SSL_CERT_FILE="/etc/ssl/certs/ca-certificates.crt" \
          -e REQUESTS_CA_BUNDLE="/etc/ssl/certs/ca-certificates.crt" \
          -- uvx plane-mcp-server stdio
      args:
        executable: /bin/bash
      register: plane_mcp_result
      changed_when: plane_mcp_result.rc == 0
      failed_when: false
      when: plane_api_key | length > 0 and plane_workspace_slug | length > 0

    - name: Display Plane MCP result
      ansible.builtin.debug:
        msg: "Plane MCP stdout: {{ plane_mcp_result.stdout | default('') }} stderr: {{ plane_mcp_result.stderr | default('') }}"
      when: plane_mcp_result is defined and plane_mcp_result.rc is defined and plane_mcp_result.rc != 0

    - name: Display Plane connection info
      ansible.builtin.debug:
        msg: "Plane MCP configured with official plane-mcp-server to connect to: {{ plane_api_url }}"
      when: plane_api_key | length > 0 and plane_workspace_slug | length > 0

    - name: Plane MCP skipped notice
      ansible.builtin.debug:
        msg: "Plane MCP skipped - PLANE_API_KEY and PLANE_WORKSPACE_SLUG not set. Configure after Plane setup."
      when: plane_api_key | length == 0 or plane_workspace_slug | length == 0

    # Note: Rewind plugin and dg-marketplace are configured via settings.json
    # (extraKnownMarketplaces and enabledPlugins arrays)
    # Claude Code will auto-enable plugins when it starts


# SSH hardening runs LAST to avoid connection issues blocking other tasks
- name: Apply SSH hardening (final step)
  hosts: all
  become: true
  gather_facts: false
  tags: [hardening]

  pre_tasks:
    - name: Ensure /run/sshd still exists
      ansible.builtin.file:
        path: /run/sshd
        state: directory
        mode: '0755'
        owner: root
        group: root

    # Verify socket activation is still disabled before ssh_hardening runs
    - name: Verify ssh.socket is stopped, disabled and masked
      ansible.builtin.systemd:
        name: ssh.socket
        state: stopped
        enabled: false
        masked: true
      register: ssh_socket_verify_result
      failed_when: false

    - name: Log ssh.socket verification status if unexpected
      ansible.builtin.debug:
        msg: "Note: ssh.socket verification returned: {{ ssh_socket_verify_result.msg | default('OK') }}"
      when: ssh_socket_verify_result is failed

    # Remove any remaining socket activation config that may have been recreated
    - name: Remove socket activation configuration files (second pass)
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /etc/systemd/system/ssh.service.d/00-socket.conf
        - /etc/systemd/system/ssh.socket.d/addresses.conf
        - /etc/systemd/system/ssh.service.requires/ssh.socket

    - name: Reload systemd daemon
      ansible.builtin.systemd:
        daemon_reload: true

    # Check what's holding port 22 for debugging
    - name: Check what process is using port 22
      ansible.builtin.shell: ss -tlnp | grep ':22' || true
      register: port_22_check
      changed_when: false

    - name: Display port 22 usage
      ansible.builtin.debug:
        msg: "Port 22 status: {{ port_22_check.stdout | default('Port 22 is free') }}"

    # Test sshd config before attempting to start
    - name: Test sshd configuration validity before starting
      ansible.builtin.command: sshd -t
      register: sshd_pretest
      ignore_errors: true
      changed_when: false

    - name: Display sshd config error if test failed
      ansible.builtin.debug:
        msg: "sshd -t failed: {{ sshd_pretest.stderr }}"
      when: sshd_pretest.rc != 0

    - name: Fail if sshd config is invalid
      ansible.builtin.fail:
        msg: "sshd configuration is invalid. Check /etc/ssh/sshd_config. Error: {{ sshd_pretest.stderr }}"
      when: sshd_pretest.rc != 0

    # Check if sshd is already running - if so, we don't need to start it
    - name: Check if sshd is already running
      ansible.builtin.shell: pgrep -x sshd > /dev/null && echo "running" || echo "stopped"
      register: sshd_running
      changed_when: false

    - name: Display sshd status
      ansible.builtin.debug:
        msg: "sshd is {{ sshd_running.stdout }}"

    # Only try to start if not already running
    - name: Start ssh.service if not running
      ansible.builtin.systemd:
        name: ssh.service
        state: started
        enabled: true
      when: sshd_running.stdout == "stopped"

  roles:
    - role: devsec.hardening.ssh_hardening

  post_tasks:
    # Test sshd config before attempting reload
    - name: Test sshd configuration validity
      ansible.builtin.command: sshd -t
      register: sshd_test
      ignore_errors: true
      changed_when: false

    - name: Show sshd config test result
      ansible.builtin.debug:
        msg: "sshd -t output: {{ sshd_test.stderr | default('OK') }}"
      when: sshd_test.rc != 0

    - name: Show generated sshd_config if test failed
      ansible.builtin.command: cat /etc/ssh/sshd_config
      register: sshd_config_content
      when: sshd_test.rc != 0
      changed_when: false

    - name: Display sshd_config content
      ansible.builtin.debug:
        msg: "{{ sshd_config_content.stdout_lines }}"
      when: sshd_test.rc != 0 and sshd_config_content is defined

    # Manually reload SSH since we disabled ssh_server_enabled to skip the role's handler
    # Try reload first, fall back to restart if reload fails (Ubuntu 24.04 quirk)
    - name: Reload SSH service to apply hardening config
      ansible.builtin.systemd:
        name: ssh
        state: reloaded
      when: sshd_test.rc == 0
      register: ssh_reload_result
      failed_when: false

    - name: Restart SSH service if reload failed
      ansible.builtin.systemd:
        name: ssh
        state: restarted
      when: sshd_test.rc == 0 and ssh_reload_result is defined and ssh_reload_result.failed | default(false)

    - name: Fail if sshd config is invalid
      ansible.builtin.fail:
        msg: "sshd configuration is invalid - SSH NOT reloaded. Fix config and retry."
      when: sshd_test.rc != 0
